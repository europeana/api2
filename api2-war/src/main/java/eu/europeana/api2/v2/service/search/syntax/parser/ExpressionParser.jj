options {
    IGNORE_CASE = false;
    STATIC = false;
}

PARSER_BEGIN(SearchExpressionParser)


package eu.europeana.api2.v2.service.search.syntax.parser;


import eu.europeana.api2.v2.service.search.syntax.converter.*;
import eu.europeana.api2.v2.service.search.syntax.field.*;
import eu.europeana.api2.v2.service.search.syntax.function.*;
import eu.europeana.api2.v2.service.search.syntax.model.*;
import java.util.List;
import java.util.ArrayList;


public class SearchExpressionParser
{
//  public static void main(String[] args) {
//          try {
//                SearchExpressionParser parser = new SearchExpressionParser(new java.io.StringReader(args[0]));
//                parser.parse();
//                System.out.println("### Syntax check passed ####");
//
//            } catch (Throwable e) {
//                      // Catching Throwable is ugly but JavaCC throws Error objects!
//                      System.out.println("Syntax check failed for query: " + e.getMessage());
//                      e.printStackTrace() ;
//            }
//  }



}

PARSER_END(SearchExpressionParser)

SKIP:  {   " "|  "\t" | "\n" | "\r" }
TOKEN : {< #LETTERS: (["a"-"z","A"-"Z"])>  }
TOKEN: {
 <FUN_NAME:  ("date" | "dateContains" |"dateWithin" | "dateIntersects" | "interval") >
 //<FUN_NAME: (<LETTERS>)+>  //creates issue with correct string identification
 }
 TOKEN: {<FIELD_NAME  : ("issued") >}

TOKEN: {<VALUE: (<LETTERS>|<NUM>)+ >}




TOKEN: {

//<SIMPLESTRING: (["a"-"z"])+ > |
< #NUM: (["0"-"9"])+> |

<AND: "AND">|
<OR: "OR">|
<NOT: "NOT">|

<LPAR :"("> |
<RPAR :")">

//<DATESTRING:  (<YEAR>"-"<SHORTMONTH>"-"<SHORTDAY>) | (<YEAR>"-"<SHORTMONTH>) |(<YEAR>) >|
//<YEAR: ["0"-"9"] ["0"-"9"] ["0"-"9"] ["0"-"9"]>| <SHORTMONTH: ["0"]["1"-"9"]| ["1"] ["0"-"2"]>|
//<SHORTDAY: ["0"]["1"-"9"]| ["1"] ["0"-"9"] | ["2"] ["0"-"9"] | ["3"] ["0"-"1"]>|
////<PARAM_VAL: "dcterms_created" >|

}

SyntaxExpression parse():{
 SyntaxExpression top;}
{
 top= TopExpression(){return top;} <EOF>
}

TopLevelExpression TopExpression():{
  TopLevelExpression top=null;
  TopLevelExpression binaryExpression=null;
  TopLevelExpression negationExpression=null;
  }
{
  (["("  top=TopExpression() ")" |
   <NOT> top=TopExpression(){if(top!=null){top = new NotExpression(top);}}|
         top=IndividualExpressions()
   ]
   binaryExpression=BinaryExpression(top){ if(binaryExpression != null ){top=binaryExpression;}
    }) {return top; }
}

BinaryArgumentExpression BinaryExpression(TopLevelExpression left):{
 TopLevelExpression right =null;
 }{
(<OR> right=TopExpression()){return new OrExpression(left,right);} | (<AND> right=TopExpression(){return new AndExpression(left,right);}) |{}{return null;}
}

TopLevelExpression IndividualExpressions():{
  TopLevelExpression exp;
 } {
    ( exp=FunctionExpression()
    |  exp=FieldQueryExpression()
    |  exp=ValueExpression()
    )
    {return exp;}

}

FunctionExpression FunctionExpression():{
  String functionName="";
  List<ArgumentExpression> paramList ;
  }{
 (functionName=FunctionName()<LPAR>paramList=Arguments()<RPAR>)
{return new FunctionExpression(FunctionRegistry.INSTANCE.getFunction(functionName),paramList);}
}
String FunctionName():{ Token t;}{
t=<FUN_NAME> {return t.image;}

}


List<ArgumentExpression> Arguments():{
List<ArgumentExpression> paramList = new ArrayList<ArgumentExpression>();
ArgumentExpression argExpr=null;
}{
(argExpr=ArgumentExpressionProduction(){paramList.add(argExpr);}("," argExpr=ArgumentExpressionProduction(){paramList.add(argExpr);})*)
{return paramList;}
}

ArgumentExpression ArgumentExpressionProduction():{
 ArgumentExpression argExpr=null;
 }{
(argExpr=ValueExpression() | argExpr=FunctionExpression()| {} )
 {return argExpr;}
}

FieldQueryExpression FieldQueryExpression():{
  String fieldName="";
  FieldArgumentExpression fieldArgExpr=null;
  }{
(fieldName=FieldName() ":" fieldArgExpr=FieldValueExpression())
{

System.out.println("Field name from registry :- " + FieldRegistry.INSTANCE.getField(fieldName));
System.out.println("Field value :- " + fieldArgExpr.toString());
return new FieldQueryExpression(FieldRegistry.INSTANCE.getField(fieldName),fieldArgExpr);}
}




String FieldName():{
  Token t;
  }{
  t=<FIELD_NAME> {return t.image;}

  }

FieldArgumentExpression FieldValueExpression():{ ValueExpression val ;}{
 val = ValueExpression()  {return val;}
}

ValueExpression ValueExpression():{Token t;}{
//'"' VALUE '"' |  '\'' VALUE '\'' |  VALUE
//"\"" <VALUE> "\"" |  "\'" <VALUE>|<DATESTRING> "\'" |  <VALUE>
t=<VALUE>{return new ValueExpression(t.image);}
}











